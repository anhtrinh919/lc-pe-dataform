config {
  type: "view",
  schema: "marts",
  tags: ["sales","promo","daily","agent"]
}

/* Grain: sale_date × store_id × article_code × promo_id
   - Sales aggregated at SKU–store–day, then overlaid per promo_id.
   - Only promo rows are emitted (promo_id NOT NULL).
*/

-- Daily sales per SKU–store–day
WITH sales_base AS (
  SELECT
    s.sale_date                         AS sale_date,
    CAST(s.store_id       AS STRING)    AS store_id,
    CAST(s.article_code   AS STRING)    AS article_code,
    ARRAY_AGG(DISTINCT CAST(s.supplier_code AS STRING) IGNORE NULLS
              ORDER BY CAST(s.supplier_code AS STRING))[SAFE_OFFSET(0)] AS supplier_code,
    CAST(SUM(s.quantity)     AS INT64)  AS qty,
    SUM(s.turnover)                      AS turnover,
    SUM(s.vat_amount)                    AS vat_amount,
    SUM(s.cost_value)                    AS cost_value,
    SUM(s.margin_value)                  AS margin_value,
    SAFE_DIVIDE(SUM(s.margin_value), NULLIF(SUM(s.turnover),0)) AS margin_percent
  FROM ${ref("fact_sales_daily")} s
  WHERE s.sale_date    IS NOT NULL
    AND s.store_id     IS NOT NULL
    AND s.article_code IS NOT NULL
  GROUP BY s.sale_date, s.store_id, s.article_code
),

-- Promo rows per SKU–store–day–promo
promo_item AS (
  SELECT
    p.date                           AS sale_date,
    CAST(p.store_id AS STRING)       AS store_id,
    CAST(p.article_code AS STRING)   AS article_code,
    CAST(p.promo_id AS STRING)       AS promo_id,
    MIN(NULLIF(TRIM(p.mechanic), '')) AS mechanic,  -- choose one non-blank mechanic
    MAX(p.discount_value)            AS max_discount_value,
    ARRAY_AGG(DISTINCT p.src_table IGNORE NULLS) AS promo_sources
  FROM ${ref("fact_promo_item_daily")} p
  WHERE p.date         IS NOT NULL
    AND p.store_id     IS NOT NULL
    AND p.article_code IS NOT NULL
    AND p.promo_id     IS NOT NULL
  GROUP BY p.date, p.store_id, p.article_code, p.promo_id
),

store AS (
  SELECT store_id, store_name, province, district
  FROM ${ref("dim_store")}
),
prod AS (
  SELECT article_code, article_description, division, department, fam_group, family, sub_family
  FROM ${ref("dim_product")}
),
supp AS (
  SELECT supplier_code, supplier_name
  FROM ${ref("dim_supplier")}
)

SELECT
  p.sale_date,
  'DAY' AS grain,
  p.store_id,
  st.store_name, st.province, st.district,
  p.article_code,
  pr.article_description,
  pr.division, pr.department, pr.fam_group, pr.family, pr.sub_family,

  -- supplier from sales overlay
  s.supplier_code,
  sp.supplier_name,

  -- promo keys and attributes
  p.promo_id,
  p.mechanic,
  p.max_discount_value,
  p.promo_sources,

  -- sales measures for that SKU–store–day (repeated across promos if multiple)
  s.qty,
  s.turnover,
  s.vat_amount,
  s.cost_value,
  s.margin_value,
  s.margin_percent
FROM promo_item p
LEFT JOIN sales_base s
  ON  s.sale_date    = p.sale_date
  AND s.store_id     = p.store_id
  AND s.article_code = p.article_code
LEFT JOIN store st ON st.store_id = p.store_id
LEFT JOIN prod  pr ON pr.article_code = p.article_code
LEFT JOIN supp  sp ON sp.supplier_code = s.supplier_code

WHERE p.sale_date    IS NOT NULL
  AND p.store_id     IS NOT NULL
  AND p.article_code IS NOT NULL
  AND p.promo_id     IS NOT NULL
