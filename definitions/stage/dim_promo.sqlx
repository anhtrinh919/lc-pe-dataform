config {
  type: "incremental",
  schema: "stage",
  tags: ["promo","master"],
  bigquery: { partitionBy: "start_date", clusterBy: ["store_id","type"] }
}

/* 1) Normalize raw promo lines */
WITH base AS (
  SELECT
    SAFE_CAST(sale_date AS DATE) AS sale_date,
    store_id,
    TRIM(LOWER(COALESCE(discount_name, ''))) AS discount_name,
    TRIM(LOWER(COALESCE(discount_desc, ''))) AS discount_desc,
    TRIM(LOWER(COALESCE(subdept_code, 'N/A'))) AS subdept_code,
    SAFE_CAST(sale_incl_vat AS NUMERIC) AS sale_incl_vat,
    SAFE_CAST(discount_amount AS NUMERIC) AS discount_amount
  FROM ${ref("stage_promo_daily")}
  WHERE sale_incl_vat IS NOT NULL OR discount_amount IS NOT NULL
),

/* 2) Collapse to date-level presence per key */
d AS (
  SELECT
    sale_date, store_id, discount_name, discount_desc, subdept_code,
    SUM(discount_amount) AS disc_amt,
    SUM(sale_incl_vat)  AS sale_amt
  FROM base
  GROUP BY 1,2,3,4,5
),

/* 3) Find consecutive-day islands (campaign windows) */
marked AS (
  SELECT
    d.*,
    -- flag a new island when gap != 1 day
    CASE
      WHEN LAG(sale_date) OVER (PARTITION BY store_id, discount_name, discount_desc, subdept_code
                                 ORDER BY sale_date)
           = DATE_SUB(sale_date, INTERVAL 1 DAY)
      THEN 0 ELSE 1
    END AS island_start_flag
  FROM d
),
islands AS (
  SELECT
    *,
    SUM(island_start_flag) OVER (
      PARTITION BY store_id, discount_name, discount_desc, subdept_code
      ORDER BY sale_date
      ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS island_id
  FROM marked
),

/* 4) Campaign rollup per island */
campaign AS (
  SELECT
    store_id, discount_name, discount_desc, subdept_code, island_id,
    MIN(sale_date) AS start_date,
    MAX(sale_date) AS end_date,
    SUM(disc_amt)  AS total_discount_amount,
    SUM(sale_amt)  AS total_sale_amount,
    SAFE_DIVIDE(SUM(disc_amt), NULLIF(SUM(sale_amt),0)) AS depth_rate
  FROM islands
  GROUP BY 1,2,3,4,5
),

/* 5) Derive type/mechanics heuristics and stable promo_id */
final AS (
  SELECT
    TO_HEX(MD5(CONCAT(
      CAST(store_id AS STRING), '|',
      discount_name, '|', discount_desc, '|', subdept_code, '|',
      CAST(island_id AS STRING)
    ))) AS promo_id,
    start_date,
    end_date,
    store_id,
    subdept_code,
    -- heuristic promo type
    CASE
      WHEN REGEXP_CONTAINS(discount_desc, r'(?i)\b(buy\s*\d+\s*get|\bbogo\b|\bfree\b)') THEN 'BOGO/Bundle'
      WHEN REGEXP_CONTAINS(discount_desc, r'%') OR REGEXP_CONTAINS(discount_name, r'%') THEN 'PercentOff'
      WHEN REGEXP_CONTAINS(discount_desc, r'(?i)\b(k|vnd|Ä‘|dong|amount|off)\b') THEN 'AmountOff'
      ELSE 'Other'
    END AS type,
    STRUCT(discount_name AS name, discount_desc AS description) AS mechanics,
    depth_rate AS depth_estimate,                  -- 0..1
    total_discount_amount,
    total_sale_amount,
    CURRENT_TIMESTAMP() AS built_at
  FROM campaign
)

SELECT * FROM final
${when(incremental(), `
WHERE start_date >
  (SELECT COALESCE(MAX(start_date), DATE '1900-01-01') FROM ${self()})
`)}