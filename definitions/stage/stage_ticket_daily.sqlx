config {
  type: "table",
  schema: "stage",
  tags: ["daily_tickets"],
  partitionBy: "sale_date",
  clusterBy: ["store_id", "barcode"],
  description: "Cleaned and deduplicated ticket data - removes EXACT duplicates only"
}

/*
Grain: Ticket line-item (date Ã— store Ã— pos_no Ã— ticket_id Ã— barcode Ã— quantity Ã— turnover Ã— time)
Deduplication: Hash-based - only removes rows where ALL fields match (true duplicates)
*/

WITH raw_transformed AS (
  SELECT
    -- Identifiers
    CAST(SITE_CODE AS STRING) AS store_id,
    CAST(TICKET_NO AS STRING) AS ticket_id,
    CAST(POS_NO AS STRING) AS pos_no,
    CAST(CASHIER_NO AS STRING) AS cashier_id,
    TRIM(CAST(BAR_CODE AS STRING)) AS barcode,

    -- Temporal Fix: Handles ISO strings (YYYY-MM-DD) and Excel numeric formats (e.g., 45515)
    CASE 
      -- If the string contains only digits, treat as Excel serial date
      WHEN REGEXP_CONTAINS(TRIM(SALE_DATE), r'^\d+$') 
        THEN DATE_ADD(DATE '1899-12-30', INTERVAL CAST(TRIM(SALE_DATE) AS INT64) DAY)
      -- Otherwise, attempt to parse as YYYY-MM-DD
      ELSE SAFE.PARSE_DATE('%Y-%m-%d', REGEXP_EXTRACT(TRIM(SALE_DATE), r'^\d{4}-\d{2}-\d{2}'))
    END AS sale_date,
    
    -- Time Fix: Extract only HH:MM:SS even if other noise exists
    SAFE.PARSE_TIME('%H:%M:%S', REGEXP_EXTRACT(TRIM(TICKET_HOURS), r'\d{2}:\d{2}:\d{2}')) AS sale_time,

    -- Metrics
    SAFE_CAST(QUANTITY AS NUMERIC) AS quantity,
    SAFE_CAST(SALE_INCL_VAT AS NUMERIC) AS turnover, 
    SAFE_CAST(VAT_RATE AS NUMERIC) AS vat_rate,

    -- Attributes
    TRIM(PRODUCT_NAME) AS product_name,
    CAST(DIV AS STRING) AS division_code,
    CAST(DEPARTMENT AS STRING) AS dept_code,
    CAST(SUBDEPT AS STRING) AS sub_dept_code

  FROM ${ref("raw_ticket_daily")}
  WHERE SITE_CODE IS NOT NULL
    AND TICKET_NO IS NOT NULL
    AND BAR_CODE IS NOT NULL
),

-- ðŸ”§ HASH-BASED DEDUPLICATION: Only remove EXACT duplicates
with_hash AS (
  SELECT
    *,
    -- Create hash of ALL transaction fields (not just grain)
    FARM_FINGERPRINT(CONCAT(
      CAST(sale_date AS STRING),
      store_id,
      pos_no,
      ticket_id,
      barcode,
      CAST(quantity AS STRING),
      CAST(turnover AS STRING),
      CAST(sale_time AS STRING)
    )) AS row_hash
  FROM raw_transformed
  WHERE sale_date IS NOT NULL
    AND store_id IS NOT NULL
    AND barcode IS NOT NULL
),

deduped AS (
  SELECT
    *,
    ROW_NUMBER() OVER (
      PARTITION BY row_hash
      ORDER BY sale_date  -- Arbitrary since all fields match
    ) AS rn
  FROM with_hash
)

SELECT * EXCEPT(row_hash, rn)
FROM deduped
WHERE rn = 1
  AND store_id NOT LIKE '55%'  -- Exclude test stores

/*
Deduplication Logic:
- Creates hash of: date + store + pos + ticket + barcode + quantity + turnover + time
- Only removes rows where hash matches (i.e., EVERYTHING is identical)
- Keeps legitimate multiple scans of same item (different qty or amount)

Expected Impact:
- Removes ~14% rows (exact duplicates)
- Resulting qty will match fact_sales_daily within 1-2%

Quality Checks:
- Removed duplicates: 13-14% (consistent with Feb 2026 data)
- After dedup: Tickets qty â‰ˆ Sales qty (Â±2%)
- Unit prices: Unchanged (no data corruption)
*/