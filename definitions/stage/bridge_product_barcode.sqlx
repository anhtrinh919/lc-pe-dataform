config {
  type: "table",
  schema: "stage",
  tags: ["bridge","barcode","conformed"]
}

/*
Purpose: 
- Map barcode → article_code with observation metadata
- Grain: article_code × barcode (one-to-many relationship)
- Sources: stage_ticket_daily only (promo sources removed)
- Master: ext.master_list (canonical article_code + barcode pairs)
- Filter: Only includes products with sales history

Matching Logic:
1. Exact barcode match (highest confidence)
2. Fuzzy name_slug match (fallback, deterministic)
3. Exclude unmapped barcodes
*/

-- Step 1: Normalize Master List (Source of Truth for article_code + barcode pairs)
WITH master_pairs AS (
  SELECT
    CAST(article_code AS STRING) AS article_code,
    TRIM(CAST(barcode AS STRING)) AS barcode,
    LOWER(REGEXP_REPLACE(SV_DESC, r'[^a-zA-Z0-9]', '')) AS name_slug
  FROM ${ref("master_list")}
  WHERE article_code IS NOT NULL 
    AND barcode IS NOT NULL
),

-- Step 2: Discover barcodes from ticket transactions
ticket_barcodes AS (
  SELECT
    TRIM(CAST(barcode AS STRING)) AS barcode,
    LOWER(REGEXP_REPLACE(product_name, r'[^a-zA-Z0-9]', '')) AS name_slug,
    MIN(sale_date) AS first_seen,
    MAX(sale_date) AS last_seen,
    COUNT(*) AS hit_count
  FROM ${ref("stage_ticket_daily")}
  WHERE barcode IS NOT NULL
  GROUP BY 1, 2
),

-- Step 3: Resolve discovered barcodes → article_code using master_list
-- (Removed promo sources - now only uses ticket data)
resolved AS (
  SELECT
    t.barcode,
    t.first_seen,
    t.last_seen,
    t.total_hits,
    -- Try exact barcode match first, then fuzzy name match
    COALESCE(
      m1.article_code,  -- Exact barcode match (highest confidence)
      m2.article_code   -- Fuzzy name_slug match (deterministic fallback)
    ) AS article_code,
    CASE
      WHEN m1.article_code IS NOT NULL THEN 'BARCODE_MATCH'
      WHEN m2.article_code IS NOT NULL THEN 'NAME_FUZZY_MATCH'
      ELSE 'UNMAPPED'
    END AS mapping_method
  FROM ticket_barcodes t
  
  -- Exact barcode match
  LEFT JOIN (
    SELECT 
      barcode, 
      ARRAY_AGG(article_code ORDER BY article_code LIMIT 1)[OFFSET(0)] AS article_code
    FROM master_pairs 
    GROUP BY 1
  ) m1 ON t.barcode = m1.barcode
  
  -- Fuzzy name_slug match (deterministic: picks first alphabetically)
  LEFT JOIN (
    SELECT 
      name_slug, 
      ARRAY_AGG(article_code ORDER BY article_code LIMIT 1)[OFFSET(0)] AS article_code
    FROM master_pairs 
    WHERE name_slug IS NOT NULL AND name_slug != ''
    GROUP BY 1
  ) m2 ON t.name_slug = m2.name_slug AND m1.article_code IS NULL
),

-- Step 4: Filter to only products that have sales history
sales_articles AS (
  SELECT DISTINCT article_code
  FROM ${ref("stage_sales_daily")}
  
  UNION DISTINCT
  
  SELECT DISTINCT article_code
  FROM ${ref("stage_sales_monthly")}
)

-- Final output: article_code × barcode pairs with observation metadata
SELECT
  r.article_code,
  r.barcode,
  r.first_seen,
  r.last_seen,
  r.total_hits,
  r.mapping_method,
  (r.last_seen >= DATE_SUB(CURRENT_DATE(), INTERVAL 60 DAY)) AS is_active_recent
FROM resolved r
INNER JOIN sales_articles s 
  ON r.article_code = s.article_code  -- Only include products with sales history
WHERE r.article_code IS NOT NULL 
  AND r.mapping_method != 'UNMAPPED'  -- Exclude unresolvable barcodes