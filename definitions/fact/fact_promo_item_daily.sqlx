config {
  type: "incremental",
  schema: "fact",
  uniqueKey: ["date","store_id","article_code","promo_id"],
  bigquery: { partitionBy: "date", clusterBy: ["store_id","article_code"] },
  tags: ["promo","daily","canonical","mapping","optimized"]
}

/* Output:
   date, store_id, article_code, promo_id,
   mechanic, discount_value, discount_percent,
   start_date, end_date, src_table,
   match_method, promo_desc, article_description
*/

-- 1) Union promo sources
WITH promo_union AS (
  SELECT
    SAFE_CAST(sale_date AS DATE)          AS date,
    CAST(store_id AS STRING)              AS store_id,
    CAST(discount_name AS STRING)         AS promo_id,
    CAST(discount_name AS STRING)         AS mechanic,
    SAFE_CAST(discount_amount AS NUMERIC) AS discount_value,
    CAST(NULL AS NUMERIC)                 AS discount_percent,
    CAST(NULL AS DATE)                    AS start_date,
    CAST(NULL AS DATE)                    AS end_date,
    CAST(discount_desc AS STRING)         AS discount_desc,
    CAST(description  AS STRING)          AS promo_desc,
    CAST(barcode     AS STRING)           AS barcode,
    'stage_promo_daily'                   AS src_table
  FROM ${ref("stage_promo_daily")}

  UNION ALL

  SELECT
    SAFE_CAST(sale_date AS DATE),
    CAST(store_id AS STRING),
    CAST(discount_name AS STRING),
    CAST(discount_name AS STRING),
    SAFE_CAST(discount_amount AS NUMERIC),
    CAST(NULL AS NUMERIC),
    CAST(NULL AS DATE),
    CAST(NULL AS DATE),
    CAST(discount_desc AS STRING),
    CAST(description  AS STRING),
    CAST(barcode     AS STRING),
    'stage_promo_vll'
  FROM ${ref("stage_promo_vll")}
),

-- 2) Normalize + dedupe promos
promo_norm_rows AS (
  SELECT
    date, store_id, promo_id, mechanic, discount_value, discount_percent,
    start_date, end_date, src_table,
    promo_desc,
    REGEXP_REPLACE(UPPER(promo_desc), r'[\s\p{P}\p{S}]', '') AS promo_norm,
    SUBSTR(REGEXP_REPLACE(UPPER(promo_desc), r'[\s\p{P}\p{S}]', ''), 1, 6) AS promo_key6
  FROM promo_union
  WHERE date IS NOT NULL AND store_id IS NOT NULL AND promo_desc IS NOT NULL AND promo_id IS NOT NULL
  ${ when(incremental(), `
    AND date > (SELECT IFNULL(MAX(date), DATE '1900-01-01') FROM ${self()})
  `) }
),
promo_dist AS (
  SELECT DISTINCT
    r.date, r.store_id, r.promo_id, r.mechanic, r.discount_value, r.discount_percent,
    r.start_date, r.end_date, r.src_table, r.promo_desc, r.promo_norm, r.promo_key6
  FROM promo_norm_rows r
  WHERE LENGTH(r.promo_norm) >= 6
),

-- 3) Date bounds limited to this run
bounds AS (
  SELECT MIN(date) AS min_d, MAX(date) AS max_d FROM promo_dist
),

-- 4) Precompute product normalization once
prod_norm AS (
  SELECT
    dp.article_code,
    dp.article_description,
    REGEXP_REPLACE(UPPER(dp.article_description), r'[\s\p{P}\p{S}]', '') AS art_norm,
    SUBSTR(REGEXP_REPLACE(UPPER(dp.article_description), r'[\s\p{P}\p{S}]', ''), 1, 6) AS art_key6
  FROM ${ref("dim_product")} dp
),

-- 5) Sales only in the needed window
sales_win AS (
  SELECT
    s.sale_date,
    s.store_id,
    s.article_code,
    pn.art_norm,
    pn.art_key6,
    s.turnover
  FROM ${ref("fact_sales_daily")} s
  JOIN prod_norm pn USING (article_code)
  WHERE s.sale_date BETWEEN DATE_SUB(COALESCE((SELECT min_d FROM bounds), DATE '1900-01-01'), INTERVAL 28 DAY)
                        AND DATE_ADD(COALESCE((SELECT max_d FROM bounds), DATE '1900-01-01'), INTERVAL 7 DAY)
),

-- 6) Blocked candidate join + exact check
candidates AS (
  SELECT
    p.date,
    p.store_id,
    p.promo_id,
    p.mechanic,
    p.discount_value,
    p.discount_percent,
    p.start_date,
    p.end_date,
    p.src_table,
    p.promo_desc,
    s.article_code,
    SUM(s.turnover) AS window_turnover
  FROM promo_dist p
  JOIN sales_win s
    ON s.store_id = p.store_id
   AND s.sale_date BETWEEN DATE_SUB(p.date, INTERVAL 28 DAY) AND DATE_ADD(p.date, INTERVAL 7 DAY)
   AND s.art_key6 = p.promo_key6
  WHERE STARTS_WITH(s.art_norm, p.promo_norm)
     OR STARTS_WITH(p.promo_norm, s.art_norm)
  GROUP BY
    p.date, p.store_id, p.promo_id, p.mechanic, p.discount_value, p.discount_percent,
    p.start_date, p.end_date, p.src_table, p.promo_desc, s.article_code
),

-- 7) Best match per promo line
best AS (
  SELECT
    c.*,
    ROW_NUMBER() OVER (
      PARTITION BY c.date, c.store_id, c.promo_id, c.promo_desc
      ORDER BY c.window_turnover DESC
    ) AS rn
  FROM candidates c
)

-- 8) Final select (pull full description once)
SELECT
  b.date,
  b.store_id,
  b.article_code,
  b.promo_id,
  b.mechanic,
  b.discount_value,
  b.discount_percent,
  b.start_date,
  b.end_date,
  b.src_table,
  'prefix_desc_window_blocked' AS match_method,
  b.promo_desc,
  dp.article_description
FROM best b
JOIN ${ref("dim_product")} dp USING (article_code)
WHERE rn = 1