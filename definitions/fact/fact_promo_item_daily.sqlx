config {
  type: "incremental",
  schema: "fact",
  uniqueKey: ["date","store_id","article_code","promo_id"],
  bigquery: { partitionBy: "date", clusterBy: ["store_id","article_code"] },
  tags: ["promo","daily","canonical","mapping","optimized"]
}

/* Output columns:
   date, store_id, article_code,
   promo_id,                 -- equals discount_category (classification code)
   discount_category,        -- from discount_name_raw (classification code)
   mechanic,                 -- equals discount_desc (mechanic / "real" name text)
   discount_desc,            -- mechanic text, preserved
   discount_value, discount_percent,
   start_date, end_date, src_table,
   match_method,
   article_description       -- from promo source description (product name)
*/

-- 1) Union promo sources (normalize field names)
WITH promo_union AS (
  -- From stage_promo_daily
  SELECT
    SAFE_CAST(sale_date AS DATE)            AS date,
    CAST(store_id AS STRING)                AS store_id,

    -- classification code; also use as promo_id to keep uniqueKey stable
    CAST(discount_name_raw AS STRING)       AS discount_category,
    CAST(discount_name_raw AS STRING)       AS promo_id,

    -- "real" promo name / mechanic text
    CAST(discount_desc AS STRING)           AS discount_desc,

    -- canonical product name from source
    CAST(description  AS STRING)            AS article_description,

    -- values
    SAFE_CAST(discount_amount AS NUMERIC)   AS discount_value,
    CAST(NULL AS NUMERIC)                   AS discount_percent,
    CAST(NULL AS DATE)                      AS start_date,
    CAST(NULL AS DATE)                      AS end_date,
    CAST(barcode     AS STRING)             AS barcode,
    'stage_promo_daily'                     AS src_table
  FROM ${ref("stage_promo_daily")}

  UNION ALL

  -- From stage_promo_vll (kept as-is, assuming same structure)
  SELECT
    SAFE_CAST(sale_date AS DATE)            AS date,
    CAST(store_id AS STRING)                AS store_id,
    CAST(discount_name AS STRING)           AS discount_category,
    CAST(discount_name AS STRING)           AS promo_id,
    CAST(discount_desc AS STRING)           AS discount_desc,
    CAST(description  AS STRING)            AS article_description,
    SAFE_CAST(discount_amount AS NUMERIC)   AS discount_value,
    CAST(NULL AS NUMERIC)                   AS discount_percent,
    CAST(NULL AS DATE)                      AS start_date,
    CAST(NULL AS DATE)                      AS end_date,
    CAST(barcode     AS STRING)             AS barcode,
    'stage_promo_vll'                       AS src_table
  FROM ${ref("stage_promo_vll")}
),

-- 2) Normalize + dedupe by store/date/promo_id + article_description text
promo_norm_rows AS (
  SELECT
    date,
    store_id,
    promo_id,
    discount_category,
    discount_desc,
    -- keep a mechanic alias for downstream compatibility
    discount_desc AS mechanic,
    discount_value,
    discount_percent,
    start_date,
    end_date,
    src_table,
    article_description,
    REGEXP_REPLACE(UPPER(article_description), r'[\\s\\p{P}\\p{S}]', '') AS promo_norm,
    SUBSTR(
      REGEXP_REPLACE(UPPER(article_description), r'[\\s\\p{P}\\p{S}]', ''),
      1,
      6
    ) AS promo_key6
  FROM promo_union
  WHERE date IS NOT NULL
    AND store_id IS NOT NULL
    AND article_description IS NOT NULL
    AND promo_id IS NOT NULL
  ${ when(incremental(), `
    AND date > (SELECT IFNULL(MAX(date), DATE '1900-01-01') FROM ${self()})
  `) }
),

promo_dist AS (
  SELECT DISTINCT
    r.date,
    r.store_id,
    r.promo_id,
    r.discount_category,
    r.discount_desc,
    r.mechanic,
    r.discount_value,
    r.discount_percent,
    r.start_date,
    r.end_date,
    r.src_table,
    r.article_description,
    r.promo_norm,
    r.promo_key6
  FROM promo_norm_rows r
  WHERE LENGTH(r.promo_norm) >= 6
),

-- 3) Date bounds for the current run
bounds AS (
  SELECT
    MIN(date) AS min_d,
    MAX(date) AS max_d
  FROM promo_dist
),

-- 4) Precompute product normalization
prod_norm AS (
  SELECT
    dp.article_code,
    dp.article_description,
    REGEXP_REPLACE(UPPER(dp.article_description), r'[\\s\\p{P}\\p{S}]', '') AS art_norm,
    SUBSTR(
      REGEXP_REPLACE(UPPER(dp.article_description), r'[\\s\\p{P}\\p{S}]', ''),
      1,
      6
    ) AS art_key6
  FROM ${ref("dim_product")} dp
),

-- 5) Consider only sales in the relevant window
sales_win AS (
  SELECT
    s.sale_date,
    s.store_id,
    s.article_code,
    pn.art_norm,
    pn.art_key6,
    s.turnover
  FROM ${ref("fact_sales_daily")} s
  JOIN prod_norm pn USING (article_code)
  WHERE s.sale_date BETWEEN DATE_SUB(COALESCE((SELECT min_d FROM bounds), DATE '1900-01-01'), INTERVAL 28 DAY)
                        AND DATE_ADD (COALESCE((SELECT max_d FROM bounds), DATE '1900-01-01'), INTERVAL 7  DAY)
),

-- 6) Candidate matches: block by 6-char key, then prefix check, rank by window turnover
candidates AS (
  SELECT
    p.date,
    p.store_id,
    p.promo_id,
    p.discount_category,
    p.discount_desc,
    p.mechanic,
    p.discount_value,
    p.discount_percent,
    p.start_date,
    p.end_date,
    p.src_table,
    p.article_description,
    s.article_code,
    SUM(s.turnover) AS window_turnover
  FROM promo_dist p
  JOIN sales_win s
    ON s.store_id = p.store_id
   AND s.sale_date BETWEEN DATE_SUB(p.date, INTERVAL 28 DAY)
                       AND DATE_ADD (p.date, INTERVAL 7 DAY)
   AND s.art_key6 = p.promo_key6
  WHERE STARTS_WITH(s.art_norm, p.promo_norm)
     OR STARTS_WITH(p.promo_norm, s.art_norm)
  GROUP BY
    p.date,
    p.store_id,
    p.promo_id,
    p.discount_category,
    p.discount_desc,
    p.mechanic,
    p.discount_value,
    p.discount_percent,
    p.start_date,
    p.end_date,
    p.src_table,
    p.article_description,
    s.article_code
),

best AS (
  SELECT
    c.*,
    -- IMPORTANT: partition by the same keys as uniqueKey so each
    -- (date, store_id, article_code, promo_id) has at most 1 row
    ROW_NUMBER() OVER (
      PARTITION BY
        c.date,
        c.store_id,
        c.promo_id,
        c.article_code
      ORDER BY
        c.window_turnover DESC
    ) AS rn
  FROM candidates c
)

-- 7) Final
SELECT
  b.date,
  b.store_id,
  b.article_code,
  b.promo_id,                 -- equals discount_category (classification code)
  b.discount_category,
  b.mechanic,                 -- from discount_desc
  b.discount_desc,
  b.discount_value,
  b.discount_percent,
  b.start_date,
  b.end_date,
  b.src_table,
  'prefix_desc_window_blocked' AS match_method,
  b.article_description
FROM best b
WHERE rn = 1